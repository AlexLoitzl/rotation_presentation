\documentclass[runningheads, orivec]{llncs}
%
%
\usepackage{geometry}
\geometry{
  a4paper,         % or letterpaper
  textwidth=14cm,  % llncs has 12.2cm
  textheight=22cm, % llncs has 19.3cm
  heightrounded,   % integer number of lines
  hratio=1:1,      % horizontally centered
  vratio=2:3,      % not vertically centered
}
\usepackage[T1]{fontenc}
% T1 fonts will be used to generate the final print and online PDFs,
% so please use T1 fonts in your manuscript whenever possible.
% Other font encondings may result in incorrect characters.
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%% MY PACKAGES %%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{xspace}
\usepackage{subcaption}
%\usepackage[gray]{xcolor}
\usepackage{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc, arrows.meta, math, positioning, decorations.pathreplacing, patterns, shapes}
\usepackage[colorlinks=true, linkcolor=blue, urlcolor=blue, citecolor = blue]{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{semantic}
\usepackage{mathtools}
\usepackage{todonotes}
\usepackage[acronym]{glossaries}
\usepackage{bbding}
\usepackage{orcidlink}
\usepackage[capitalize]{cleveref}
\usepackage{xpatch}
\usepackage{eulervm}

\usepackage{pgfplots}
\usepackage{pgfplotstable}
\pgfplotsset{compat=1.16}
\usepgfplotslibrary{groupplots}

\definecolor{codebg}{HTML}{eeeeee}
\usepackage{minted}
\setminted{fontsize=\footnotesize, bgcolor=codebg}
\usemintedstyle{tango}

\usepackage{newunicodechar}
\newunicodechar{Π}{\ensuremath{\Pi}}
\newunicodechar{Φ}{\ensuremath{\Phi}}
\newunicodechar{∗}{\ensuremath{\ast}}
\newunicodechar{⌜}{\ensuremath{\ulcorner}}
\newunicodechar{⌝}{\ensuremath{\urcorner}}
\newunicodechar{∃}{\ensuremath{\boldsymbol\exists}}
\newunicodechar{κ}{\ensuremath{\kappa}}
\newunicodechar{σ}{\ensuremath{\sigma}}
\newunicodechar{↪}{\ensuremath{\hookrightarrow}}
\newunicodechar{≡}{\ensuremath{\equiv}}
\newunicodechar{□}{\ensuremath{\square}}


% If you use the hyperref package, please uncomment the following two lines
% to display URLs in blue roman font according to Springer's eBook style:
\usepackage{color}
\renewcommand\UrlFont{\color{blue}\rmfamily}
\urlstyle{rm}

\glsdisablehyper
\newacronym{cfg}{CFG}{context-free grammar}

\begin{document}

\title{Modular I/O Reasoning in DimSum}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Alexander Loitzl\Envelope\orcidlink{0009-0002-7417-2537}}%
\authorrunning{A. Loitzl}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%

\institute{Institute of Science and Technology Austria, Klosterneuburg, Austria\\
\email{alexander.loitzl@ista.ac.at}}
%
\maketitle              % typeset the header of the contribution
%
%
% Abstract: an introduction conveying the general scientific background, research methodology and overall investigation status of the overarching scientific question in the pertinent scientific field

\begin{abstract}
  Hoare logic provides a framework for modularly reasoning about program behavior and in the more powerful setting of separation logic can be used to verify various low-level aspects of interest like memory-safety and exclude data-races. On the other hand, reasoning about the input/output behavior of a program has not been studied much.
  This is the main motivation for ongoing work built on top of DimSum enabling modular proofs.
  We report on the rotation project which aim was to first gain some insights into DimSum and the tools used in it's proofs and then to turn to experimenting with I/O reasoning.
  We added some new lemmas and gained valuable insights into the fixing of the environment for each module.
\end{abstract}

\section{Background}
Below, we briefly present relevant aspects of DimSum\cite{dimsum} and the initial motivation for the project.
\subsection{Modular I/O Reasoning}

In \cite{io1,io2},  a modular approach based on separation logic for capturing the interactive (I/O) behavior programs is proposed. We build on their approach, but use more general abstract nested hoare triples rather than their approach based on Petri Nets. The arbitrary nesting of triples allows us to write specifications in which we capture the execution order of functions and allows us to refer to previous output values rather than introducing existential quantifiers.

Below we give a spec for a simple echo function with a nested specification. Note that the binder for the postcondition is a parameter of the specification. In particular, the specification can be read as, \textit{If we call echo with no arguments, then call getc with no arguments, then call putc with the output of getc, echo returns 0}.
\begin{align*}
  \texttt{echo}\Biggl\{&\lambda \text{ es POST}{}_e\text{, ⌜es = [ ]⌝}\ \ast\\
  &\ \ \texttt{getc}\biggl\{\lambda \text{ es POST}{}_1\text{, ⌜es = [ ]⌝}\ \ast\ \text{POST}_1\ \Bigl(\lambda \text{ v, }\\
  &\quad\ \ \texttt{putc}\bigl\{\lambda \text{ es POST}_2 \text{, ⌜es = v⌝}\ \ast\ \text{POST}_2 \bigl(\lambda \text{\_, POST}_e\ (\lambda \text{v, ⌜v = 0⌝})\bigr)\bigr\}\Bigr)\biggr\}\Biggr\}
\end{align*}

To transform this into a more modular specification, we can then capture I/O actions as abstract predicates. Below we give an example, where we factor out the spec for getc, capturing reads from a sequence of increasing numbers. Intuitively, the abstract predicate will capture the resource needed to call getc, i.e., $P v$ could stand for ownership of a pointer to a location storing the value v.
\begin{align*}
  &\texttt{getc\_spec}(P) \coloneqq\texttt{getc}\bigl\{\lambda \text{ es POST} \text{, $\exists$ v, P v $\ast$ ⌜es = [ ]⌝}\ \ast\\
  &\ \ \text{POST }(\lambda \text{ ret, ⌜ret = v⌝ $\ast$ P (v + 1)})\bigr\}\\[1em]
%
  &\texttt{echo\_spec}(P) \coloneqq\\
  &\ \ \texttt{echo}\Bigl\{\lambda \text{ es POST}_e \text{, $\exists$ v, P v $\ast$ ⌜es = [ ]⌝ $\ast$ \texttt{getc\_spec}(P)}\ \ast\\
  &\quad\ \ \texttt{putc}\bigl\{\lambda \text{ es POST}_1 \text{, ⌜es = v⌝}\ \ast\ \text{POST}_1 \bigl(\lambda \text{\_, POST}_e\ (\lambda \text{v, ⌜v = 0⌝})\bigr)\bigr\}\Bigr\}
\end{align*}

\subsection{DimSum}
DimSum is a framework for multi-language reasoning realized in the Rocq theorem prover. Program semantics are defined as LTS (modules) which, like in process algebra, interact by synchronizing on events. DimSum allows for interaction between arbitrary modules, as long as they agree on the used events. In particular, this can allow interaction of modules from different languages or specifications. This is achieved by special modules which translate events between two languages. Similarly, two modules can be linked by wrapping them in a special module which captures the outgoing events and potentially synchronizing with a linked module.

The recently added suppport for Hoare-style reasoning is othogonal to the previous focus of DimSum. Rather than ensuring smooth interaction of modules, we are focusing on the module-local reasoning by abstracting the environment and viewing it abstractly as a postcondition $\Pi$. The Hoare-triples are then parameterized by such a post-condition and the notion of a \texttt{switch} is introduced to impose pre- and post-conditions on the environment. Intuitively, a switch captures a change from module local reasoning to the environment. We will see some examples later.

\section{Rotation Project}

The main objective of the rotation (as stated in the pre-rotation protocol) was to get familiar with DimSum and the tools used in its design. This includes the SSreflect tactic language, the Iris Proof Mode (and Separation logic), and carrying out proofs in both the original and the new modular proof styles.

Small example programs, moslty with I/O behavior, but also some memory management and recursion, served as an incremental way to get introduced to the new topics. Rather quickly, the main challenge came up: Writing a fully modular specification for a recursive program with I/O.

\subsection{Writing correct modular specifications}

One of the example problems stated is to prove a linked module consisting of a Rec program \texttt{echo} and a Spec program \texttt{getc} refines a Spec program \texttt{echo\_getc} as stated below, where we write $\oplus$ for \emph{semantic linking} of two modules.
\[(\texttt{echo} \oplus \texttt{getc}) \preceq \texttt{echo\_getc}\]

The programs are defined in \cref{fig:def}, where most notably, \texttt{echo} recursively calls \texttt{getc} and uses the output as argument for \texttt{putc}. The proof of the refinement has two patterns of interaction between the modules. One is the call of \texttt{getc} to the linked module, the other, an external call to \texttt{putc}, which is a emited as visible events for both the program and the specification.

\begin{figure}[h]
  \centering
  \begin{subfigure}[b]{0.21\textwidth}
    \centering
    \begin{minipage}{\textwidth}
      \centering
      \inputminted[bgcolor=codebg]{c} {echo.rec}
    \end{minipage}
  \end{subfigure}
  %% \hspace{3em}
  \hfill
  \begin{subfigure}[b]{0.35\textwidth}
    \centering
    \begin{minipage}{\textwidth}
      \centering
      \inputminted[bgcolor=codebg]{coq} {getc.spec}
    \end{minipage}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.4\textwidth}
    \centering
    \begin{minipage}{\textwidth}
      \centering
      \inputminted[bgcolor=codebg]{coq} {echo_getc.spec}
    \end{minipage}
  \end{subfigure}

  \caption{Rec progam \texttt{echo} (left), Spec program \texttt{getc} (middle), and Spec program \texttt{echo\_getc} (right) specifying the module linking \texttt{echo} and \texttt{getc}.}
  \label{fig:def}
\end{figure}

The proof itself is quite straightforward in the original proof style of DimSum, as it consists mainly of interaction between modules. The next step, a monolothic Hoare-style proof, is more cumbersome, but is also quite straightforward. The main challenge lies in the correct creation and use of the ghost variables capturing the state of the modules.

The main challenge is writing a fully modular specification, i.e., writing specifications for the different calls. The main problem, which is ensured to exist, is the correct abstraction of the ownership of resources, which allow you to call things. The recursive nature of the program requires one to correctly return all resources in order to be able to use the inductive hypothesis.

\cref{fig:specs} contains a concrete specification, which specifies the behavior of calls to getc from the Rec module. The conclusion states that there is some abstract predicate P, that we know holds for 0 (the starting point of the increasing sequence getc reads from), and then get a persistent statement that if we own this predicate for some value v, then a call of \texttt{getc} returns this value and gives back ownership of P (v + 1). In the premise, we require some other abstract predicate (which will be instantiated with the state of the linking module) and additionally a hypothesis which constrains $\Pi_r$ and $\Pi_l$. This allows us to switch out of the Rec module, into the spec module and back again, returning the updated predicate PL, i.e., the updated state of the linking module.

\begin{figure}[h]
  \centering
  \begin{subfigure}[b]{0.75\textwidth}
    \centering
    \begin{minipage}{\textwidth}
      \centering
      \inputminted[bgcolor=codebg]{coq} {getc_prepost_short.v}
    \end{minipage}
  \end{subfigure}
  \hfill
  %% \begin{subfigure}[b]{0.42\textwidth}
  %%   \centering
  %%   \begin{minipage}{\textwidth}
  %%     \centering
  %%     \inputminted[bgcolor=codebg]{coq} {echo_prepost.v}
  %%   \end{minipage}
  %% \end{subfigure}
  \begin{subfigure}[b]{0.75\textwidth}
    \centering
    \begin{minipage}{\textwidth}
      \centering
      \inputminted[bgcolor=codebg]{coq} {sim_getc.v}
    \end{minipage}
  \end{subfigure}
  %
  \caption{Desirable (?) Specification of the call to \texttt{getc}}
  \label{fig:specs}
\end{figure}

One interesting detail to point out is the newly introduced \texttt{switch\_linked\_fixed} predicate. The rotation project showed us we should fix the $\Pi$s.

\subsection{Switching Notation}

One other interesting aspect of the rotation is forming an intuition for switches and how to communicate it. In parallel to the actual verification we discussed various ways of annotating things with their pre- and post conditions.

The specifications in \cref{fig:specs} are written in our current favorite notation, proposed by Michael.
Main points of consideration were the scope of binders, the sequantial nature of the specification (although nested), and the ease of seeing what is an assumption and what requires a proof.

The notation fulfills these criteria, not introducing any parenthesis which may suggest end of a scope of a variable and through indentation suggests sequentiality. The included wand -$\ast$ and separating conjunction $\ast$ immediately suggest the nature of the statements, modularly depending on the position of the statement.
If we need to prove a switch a \emph{wand} becomes assumption and conjunction obligations, whereas if we have a switch as an assumption, it is the other way around.

\section{Discussion}

The rotation was of a quite explorative nature and there are still many open problems and future directions. Below we discuss the takeaways and the most immediate next steps. Moreover, we talk about the challenges, as this is closely related to communication of intuition and the goal of developing an intuitive proof framework.

\subsection{Outcome}

First focusing on the concrete outcomes, there is a full proof of the function of interest in the original proof style of DimSum\footnote{} , and both a monolothic\footnote{} and a partially modular\footnote{} proof with the new Hoare-style reasoning.

Additionally, we developed a new lemma, allowing for simpler reasoning with the \texttt{TCallRet} operation\footnote{}, specified to new linking definitions for linking with a known module\footnote{} and developed new abstract postconditions capturing the state of the linking module\footnote{}, in order to have fixed $\Pi$s.

This brings us to one of the main insights, namely that there should be one fixed $\Pi$ per module, capturing the state. This is necessary for clean induction, and requires additional ghost state to have a fixed predicate parameterized by the ghost variables, rather than the state of other modules.

\subsection{Challenges \& Future Work}

One of the goals of the rotation, was to develop an intuition for DimSum and it's new, partially finished, reasoning style. The means to achieve this, was in a way top down, immediately starting with the new reasoning mode and trying to fill in details as they come up. It turned out that this was quite challenging, as even in the abstract, the specifications are strongly tied to the way more complex modules, like the linking module, behave.

This also closely ties into another challenge, namely how to communicate the work. During the preparation for the presentation it became clear, that it is quite difficult to give insights into the specifications without first giving a somewhat detailed overview of the DimSum framework. It remains an open challenge to find not only a good way to communicate but also to provide infrastructure to write specs that abstract away the peculiarities.

One other open problem is tying all of this into multilanguage, but the main problems are actually more abstract.

\bibliographystyle{splncs04.bst}
\bibliography{references}

\end{document}
